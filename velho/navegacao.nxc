//Codigo Master

//Opcao de estrategia:
/*Robo A (o que vai entrar em todos os modulos) algoritmo para percorrer todos
  os modulos:
  anda distancia fixa pra frente (sair do pequeno modulo onde o robo inicia)
  
  vira a esquerda (o lado e arbitrario , entretanto mudando o sentido que o robo
  vai circular mudaremos as proximas direçoes para virar)
  
  acelera ate os 2 sensores de toque serem ativados , entao vire a direita
  
  quando o sensor ultrasonico parar de detectar parede "tenta entrar"(verifica 
  a linha preta no chao ou nao)
  
  ao sair do modulo != do central :
  acelera distancia fixa , retorna distancia fixa de re , vira 180 graus
  e acha novamente a linha preta (ou seja achou a entrada dnv)
  
  volta a percorrer o modulo inicial virando para direita.
  */

//Definicao dos Estados
#define MODULOCENTRAL 0		//Quando o robo se encontra no modulo central
#define NAVEGACAO 1			//Quando se encontra no labirinto ou no buraco
#define VOLTA 2				//Voltando para o modulo central

//Definicao de comunicacao
#define BT_CONN 1			//Canal de comunicacao Bluetooth
#define INBOX 1				//Caixa de mensagens recebidas
#define OUTBOX 5			//Caixa de mensagens enviadas

//Definicao de mensagens
#define MSG_SENSOR_DIR 2
#define MSG_SENSOR_ESQ 1

//Definicao de Sensores
#define SENSOR_COR SENSOR_1

//Definicao de navegacao
#define FRENTE 1
#define TRAS 0
#define ESQUERDA 1
#define DIREITA 0
#define ANGULO 359	//Fazer medicao
#define TEMPO_90_HORARIO 900

struct Sensores {
	int cor;
	
	int som_esq;
	int som_dir;
	
	bool toque_esq;
	bool toque_dir;
};

//Variaveis globais
int estado;					//Estado da maquina de estados
Sensores sensores;

//Move o robo em linha reta para frente ou para tras.
void andar(int sentido, int potencia) {
	if(sentido == FRENTE)
		OnFwdSync(OUT_AB, potencia, -3);
	else
		OnRevSync(OUT_AB, potencia, 0);
}

void andarT(int sentido, int potencia, int tempo) {
	if(sentido == FRENTE)
		OnFwdSync(OUT_AB, potencia, -3);
	else
		OnRevSync(OUT_AB, potencia, 0);

	Wait(tempo);
	Off(OUT_AB);
}

//Direito = B, Esquerdo = A
//Gira o robo em 90 graus. 
void girar(int sentido, int potencia, int tempo) {
	if(sentido == ESQUERDA) {
		OnRev(OUT_A, potencia);
		OnFwd(OUT_B, potencia);
	}
	else {
		OnFwd(OUT_A, potencia);
		OnRev(OUT_B, potencia);
	}

	Wait(tempo);
	Off(OUT_AB);
}

//Definir comunicao bluetooth
sub BTCheck(int conn)
{
	//Checa comunicação bluetooth
	if(!BluetoothStatus(conn)==NO_ERR)
	{
		TextOut(5, 0, "ERROR BT");
		Wait(1000);
		Stop(true);
	}
}

//Funcao que checa obstaculos
//Verificar viabilizacao dessa funcao ser uma task
task atualizaSensores()
{
  SetSensorUltrasonic(IN_4);
  SetSensorUltrasonic(IN_3);
	SetSensorColorRed(IN_1);
	int input = 0;
	while(1) {

		//Atualiza sensor de toque (Bluetooth)
    ReceiveRemoteNumber(INBOX,true,input);
    Wait(10);

      switch (input)
      {
         case -1:
              sensores.toque_esq = false;
              sensores.toque_dir = false;
              break;

         case 1:
              sensores.toque_esq = false;
              sensores.toque_dir = true;
              break;

         case 10:
              sensores.toque_esq = true;
              sensores.toque_dir = false;
              break;

         case 11:
              sensores.toque_esq = true;
              sensores.toque_dir = true;
              break;
      }

  	//Atualiza sensores de cor
		sensores.cor = 	SENSOR_COR;
		
		//Atualiza sensores ultrassonicos 
		sensores.som_dir = SensorUS(IN_3);
		sensores.som_esq = SensorUS(IN_4);
	}
}

//Funcao que sai de obstaculos


//Modulo Central
void central()
{

}

//Funcao referente ao primeiro estado
void moduloCentral()
{

	int flag, distanciaInicial;

	andarT(FRENTE, 60, 400);
	girar(DIREITA, 60, TEMPO_90_HORARIO);	
	andar(FRENTE, 60);
	until(sensores.toque_dir == true && sensores.toque_esq == true);
	Off(OUT_AB);
	andarT(TRAS, 60, 100);
	girar(ESQUERDA, 60, TEMPO_90_ESQUERDA);
	distanciaInicial = sensores.som_esq;
	//50 eh uma constante de seguranca para evitar problemas do valor do ultrasom
	while(sensores.som_esq > distanciaInicial + 50) {
		andar(FRENTE, 60);
		if(sensores.toque_dir == true && sensores.toque_esq == true) {
			andarT(TRAS, 60, 100);
			girar(DIREITA, 60, TEMPO_90_DIREITA);
		}
	} 

	//atualizaSensores();
	//caminhar reto
	//Checa o chao para ver se ja esta em outro modulo
	//Checa se existe mensagem do slave
	

}

//Imprime estado atual da struct de sensoriamento
void imprimeSensores()
{
 ClearLine(0);
 TextOut(0,0,"Cor:");
 NumOut(40,0,sensores.cor);
 

 ClearLine(10);
 TextOut(0,10,"US Esq:");
 NumOut(40,10,sensores.som_esq);


 ClearLine(20);
 TextOut(0,20,"US Dir:");
 NumOut(40,20,sensores.som_dir);
 

 ClearLine(30);
 TextOut(0,30,"TQ Esq:");
 NumOut(40,30,sensores.toque_esq);
 

 ClearLine(40);
 TextOut(0,40,"TQ Dir:");
 NumOut(40,40,sensores.toque_dir);

}

task main() {

	estado = 0;
	BTCheck(BT_CONN);
	StartTask(atualizaSensores);
	sensores.toque_dir = false;
	sensores.toque_esq = false;

	
	
    girar(DIREITA,60, TEMPO_90_HORARIO);
    Off(OUT_AB);
    Wait(1000);
    andar(FRENTE, 80);
    Wait(50);

	


	
	
	
}	
